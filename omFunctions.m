classdef omFunctions
    %collection of functions used in processing lab data. 
    
    

    % === Some defaults for figures ===
    %
    %
    %
%     set(0, 'DefaultFigureColor', [1 1 1]);
%     set(0, 'DefaultFigurePaperPosition',[2.65 4.3 3.2 2.4]);
%     set(0, 'DefaultFigurePosition', [800 500 360 270])
%     % 360x260 pixels on screen keeps same aspect ratio as 3.2x2.4 printed
%     set(0, 'DefaultFigurePosition', [300 300 720 540])
%     set(0, 'DefaultFigureDockControls', 'off')
%     set(0, 'DefaultAxesTickLabelInterpreter','latex'); 
%     set(0, 'DefaultLegendInterpreter','latex');
%     set(0,'DefaultTextInterpreter','latex')
%     FontSize = 20;    %12
%     LineWidth = 1.5;  %1
%     set(0, 'DefaultTextFontSize', FontSize);
%     set(0, 'DefaultAxesFontSize', FontSize);
%     set(0, 'DefaultAxesFontName', 'Verdana');
%     set(0, 'DefaultAxesLineWidth', LineWidth);
%     set(0, 'DefaultAxesTickLength', [0.01 0.015]);
%     set(0, 'DefaultAxesBox', 'on');
%     set(0, 'DefaultLineLineWidth', LineWidth);
%     set(0, 'DefaultLineMarkerSize', 5);
%     set(0, 'DefaultPatchLineWidth', LineWidth);


    properties
        
    end
    
    methods
        
        function [d, f] = import_mat_list(obj, file_path, direction)
            % import .mat files from directory at file_path. Struct 1xN is
            % returned. Each .mat must have same fields. 
            if nargin < 3
                direction = 'descend';
            end
            f = dir(join([file_path,'/*.mat']));
            t = struct2table(f);
            s = sortrows(t, 'name', direction);
            files = table2struct(s);
            N = length(files);
            for i = N:-1:1 %Backwards so that memory is pre allocated 
                disp(strcat("Imported ",files(i).name))
                d(N+1-i) = load(files(i).name); %not sure if there is a nice way to intialize a nxm struct.
            end
        end

        function [d, f] = import_csv_list(obj, file_path, direction)
            % import .mat files from directory at file_path. Struct 1xN is
            % returned. Each .mat must have same fields. 
            if nargin < 3
                direction = 'descend';
            end
            f = dir(join([file_path,'/*.csv']));
            t = struct2table(f);
            s = sortrows(t, 'name', direction);
            files = table2struct(s);
            N = length(files);
            for i = N:-1:1 %Backwards so that memory is pre allocated 
                disp(strcat("Imported ",files(i).name))
                d(N+1-i).data = load(files(i).name); %not sure if there is a nice way to intialize a nxm struct.
            end
        end
        
        function d = import_dat_list(obj, filename, dataLines)
            %IMPORTFILE Import data from a text file

            % Auto-generated by MATLAB on 24-Feb-2021 13:31:11

            %% Input handling

            % If dataLines is not specified, define defaults
            if nargin < 3
                dataLines = [1, Inf];
            end

            %% Setup the Import Options and import the data
            opts = delimitedTextImportOptions("NumVariables", 2);

            % Specify range and delimiter
            opts.DataLines = dataLines;
            opts.Delimiter = " ";

            % Specify column names and types
            opts.VariableNames = ["e010", "VarName2"];
            opts.VariableTypes = ["double", "double"];

            % Specify file level properties
            opts.ExtraColumnsRule = "ignore";
            opts.EmptyLineRule = "read";
            opts.ConsecutiveDelimitersRule = "join";
            opts.LeadingDelimitersRule = "ignore";

            f =  dir(join([filename,'/*.dat']));
            t = struct2table(f);
            s = sortrows(t, 'name', 'descend');
            files = table2struct(s);
            N = length(files);
            % Import the data
            for i = N:-1:1 %Backwards so that memory is pre allocated 
                disp(strcat("Imported ",files(i).name))
                data = readtable(files(i).name); 
                data = table2array(data);
                d(N+1-i,:,:) = data;
            end
        end

        function Lk = kinetic_inductance(obj, b, R)
            % accepts b fitting parameter from a*exp(-b*x)+c
            % returns kinetic inductance in pH
            if nargin < 3
                R = 50;
            end
            tau = 1/b;
            Lk = tau*R * 1e12;
        end
        
        function Lk = kinetic_inductance_rs(obj, Rs, Tc)
            Lk = 1.378*(Rs/Tc);
        end
        
        function Jdep = depairing_current_density(obj, T, Tc, rho, D)
            % T: Temperature, Tc: Critical Temperature, Rs: Normal state
            % sheet resistance, rho: Normal state resistivity, D: electron
            % diffusivity 
            % using equation 31 from clem and kogan PHYSICAL REVIEW B 86, 174521 (2012)
            % verified using PHYSICAL REVIEW APPLIED 14, 054011 (2020) 
            % 
            if nargin < 5
                D = 0.5*1e-4;
                disp('D: electron diffusivity assumed to be 0.5 (typical for NbN)')
            end
            e = 1.6022e-19; %C
            hbar = 1.0546e-34; %Js
            kb=1.3806e-23; %J/K

            N0 = 1/(2*e^2*rho*D); %Clem/Kogan between eq B2, B4

            del0 = 1.76*kb*Tc;
            
            Jdep0 = 1.491*N0*e*((del0)^(3/2))*sqrt(D/hbar);

            Jdep = Jdep0*(1-(T/Tc)^2)^(3/2); %PHYSICAL REVIEW APPLIED 9, 064037 (2018)
    
        end
        
        function I0 = I0_temp(obj, Ic, T, Tc)
            I0 = Ic./((1-(T/Tc)^2)^(3/2));
        end

        function Idep = depairing_current(obj, T, Tc, Rs, w, D)
            % T: Temperature, Tc: Critical Temperature, Rs: Normal state
            % sheet resistance, rho: Normal state resistivity, D: electron
            % diffusivity 
            % using equation 31 from clem and kogan PHYSICAL REVIEW B 86, 174521 (2012)
            % verified using PHYSICAL REVIEW APPLIED 14, 054011 (2020) 
            % 
            if nargin < 5
                D = 0.5*1e-4;
                disp('D: electron diffusivity assumed to be 0.5 (typical for NbN)')
            end
            e = 1.6022e-19; %C
            hbar = 1.0546e-34; %Js
            kb=1.3806e-23; %J/K

            del0 = 1.76.*kb.*Tc;
            
            Idep0 = 0.74.*(w.*(del0.^(3/2)))./(e.*Rs.*sqrt(hbar.*D)); %GUANG-ZHAO XU 90% paper

            Idep = Idep0.*(1-(T./Tc).^2).^(3/2); %PHYSICAL REVIEW APPLIED 9, 064037 (2018)
    
        end

        function y = inductance_fraction(x, n)
            y = (1-x^n)^(1/n);
        end

        function data = readTcTxt(obj,file_name)
            formatSpec = '%f, %f';
            sizeA = [2 Inf];
            fileID = fopen(file_name,'r');
            data = fscanf(fileID,formatSpec,sizeA);
        end
        
        function data = isw_calc(obj,file_path, number_of_switches)
            files = dir(join([file_path,'/*.mat']));
            t = struct2table(files);
            s = sortrows(t, 'name', 'descend');
            files = table2struct(s);
            N = length(files);
            for i = 1:N
                data = load(files(i).name);
                V = data.V_device;
                I = data.I_device;
                if data.Isw
                    initial_Isw = data.Isw;
                end
                num_valid = 10;
                tol = 0.5*max(diff(V));
%                 plot(diff(V))
%                 hold on
                while num_valid > number_of_switches
                    n = find(abs(diff(V))>tol);
                    num_valid = length(n);
                    tol = tol+.05*max(diff(V));
%                     plot([1 length(V)], [tol tol],'-')
                end
                isw = I(n);
                Isw = mean(abs(isw));
                if ~isnan(Isw)
                   save(files(i).name, '-append', 'Isw');
                   disp("Isw updated from: " + initial_Isw + " >> to: " + Isw)
                else
                    Isw = 0;
                    save(files(i).name, '-append', 'Isw');
                    disp("Isw updated from: "+initial_Isw+" >> to: " + Isw)
                end
            end
        end
            
        function Isw = isw_calc_IV(obj, I, V, number_of_switches)
            num_valid = 10;
            tol = 0.2*max(diff(V));
% %             plot(diff(V))
% %             hold on
            check = 1;
            while check == 1
                while num_valid > number_of_switches
                    n = find(abs(diff(V))>tol);
                    num_valid = length(n);
                    tol = tol+.05*max(diff(V));
%                     plot([1 160], [tol tol],'-')
                    if num_valid > 5*number_of_switches %Lots of jumps getting in the way of calcs
                        Isw = I(n(1));
                        return
                    end
                end
                isw = I(n);
                Isw = mean(abs(isw));
                if isnan(Isw)
%                     num_valid=num_valid-2; %reduce the number of accepted switching events
                    Isw = I(find(diff(V)>0.2*max(diff(V))));
                    Isw = Isw(1); %backup basic isw calculation
                    return
                else
                    check = 0;
                end
            end
        end
        
        function [Tc, rrr] = tccalc(obj, T, R, tolerance)

            if nargin < 4
                tol = max(R)*.1;
            else
                tol = max(R)*tolerance;
            end
            peakindex = find(R==max(R));
            peakT = T(peakindex);
            halfResistance = max(R)/2;
            i = find(R < halfResistance+tol & R > halfResistance - tol & T<peakT);
            nT = T(i); nR = R(i);
            % nT = nT(nT<peakT);
            % nR = nR(nT<peakT);
            if min(R) < 10 && length(i) < 40
                Tc = (max(nT)+min(nT))/2;
            else
                Tc = 0;
            end
            rrr = R(1)/max(R);




            print = 0;
            if print==1
                plot(T, R)
                Ax=gca;
                hold on
                plot(T(peakindex),R(peakindex),'ro')
                plot(nT, nR,'o')
                plot(T(1), R(1),'bo')
                plot(Ax.XLim,[halfResistance+tol halfResistance+tol], 'k--')
                plot(Ax.XLim,[halfResistance-tol halfResistance-tol], 'k--')
                % plot([Tc Tc],Ax.YLim, '-')
                xlabel('Temperature (K)')
                ylabel('Resistance (Ω)')
                legend("Tc="+Tc+"K, RRR="+rrr)
            end


        end

        function I = calculate_current(obj, V, R, attenuation)
            if nargin < 4
                attenuation = 0;
            end
            V = V*10^(attenuation/20);
            I = V/R;
        end
            
        
        function I = voltage2current(obj, V, attenuation, R)
            V = V*10^(attenuation/20);
            I = V/R;
        end

        function [switching_currents, avg_ic, sigma, avg_ic0, sigma0] = iv_sweep_scope(obj, data, R, shift, threshold)

            M = size(data.C2x, 1);
            freq = double(data.freq);
            v_amp = data.awg_amp/2;
            atten = double(data.atten);
            %R = 50; % cable, chip_front, chip_back. 

            times = zeros(1, M);
            x=0; y=0;
            for j = 1:M
                x = data.C2x(j,:);
                y = data.C2y(j,:);
        
                bx = x(1:end-shift+1);
                by = y(1:end-shift+1);
                
                time_step = x(2)-x(1);
                fx = x(shift:end)+shift*time_step;
                fy = y(shift:end);
                
                ydiff = fy-by;
                ydiff = [ydiff, zeros(1, shift)];
                ydiff = ydiff(x>0);
                xdiff = x(x>0);
                
                q=0;
                if q==1
                    plot(xdiff, ydiff)
                end
                threshold = max(ydiff)*0.95;
                nx = xdiff(ydiff>threshold);
                try
                    times(j) = nx(1);
                catch
                    times(j) = 0;
                end
            end
            currents = time2currentFUN(times(~isnan(times)), freq, v_amp, R, atten)*1e6;
        
            avg_ic0 = mean(currents(currents~=0));
            sigma0 = std(currents(currents~=0));
            
            avg_ic = mean(currents);
            sigma = std(currents);
            
            lower = avg_ic-min(currents);
            upper = max(currents)-avg_ic;
            
            switching_currents = currents;

        end


        function I = time2current(obj, t, f, Vpeak, R, attenuation)
            % time2current(obj, t, f, V, R, attenuation)
            % Works with RAMP signal. V 
            tpeak = (1/double(f))/4;
            V = double(Vpeak*10^(attenuation/20));
        %             V = (1-(tpeak-double(t))./tpeak).*V;
            V = V*(double(t)/tpeak);
            I = V/R;
        end
        
    end
        
        
end

function I = time2currentFUN(t, f, Vpeak, R, attenuation)
    % time2current(obj, t, f, V, R, attenuation)
    % Works with RAMP signal. V 
    tpeak = (1/double(f))/4;
    V = double(Vpeak*10^(attenuation/20));
%             V = (1-(tpeak-double(t))./tpeak).*V;
    V = V*(double(t)/tpeak);
    I = V/R;
end
% 


% exportgraphics(gcf,'filename.pdf','ContentType','vector')
